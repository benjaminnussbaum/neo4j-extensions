<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/integration"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:jms="http://www.springframework.org/schema/integration/jms"
	xmlns:rabbit="http://www.springframework.org/schema/rabbit"
	xmlns:int-amqp="http://www.springframework.org/schema/integration/amqp"
	xmlns:int-kafka="http://www.springframework.org/schema/integration/kafka"
	xmlns:task="http://www.springframework.org/schema/task"
	xsi:schemaLocation="http://www.springframework.org/schema/beans
			http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
			http://www.springframework.org/schema/integration/amqp http://www.springframework.org/schema/integration/amqp/spring-integration-amqp.xsd
			http://www.springframework.org/schema/integration
			http://www.springframework.org/schema/integration/spring-integration-3.0.xsd
			http://www.springframework.org/schema/rabbit http://www.springframework.org/schema/rabbit/spring-rabbit.xsd
			http://www.springframework.org/schema/integration/jms
			http://www.springframework.org/schema/integration/jms/spring-integration-jms-3.0.xsd
			http://www.springframework.org/schema/integration/kafka http://www.springframework.org/schema/integration/kafka/spring-integration-kafka.xsd
			http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd">

	<beans:import resource="classpath*:META-INF/spring/integrationContext.xml" />

	<!-- Testing Context only -->
	<!-- JMS -->
	<jms:message-driven-channel-adapter
		id="testJms" destination="searchUpdateTopic" channel="jmsQueueChannel" />

	<!-- <channel id="testJmsInChannel" /> -->

	<!-- <json-to-object-transformer input-channel="testJmsInChannel" output-channel="jmsQueueChannel" 
		/> -->
	<!-- type="com.sony.spe.mc.fuse.client.proxy.JobFlatProxy"/> -->

	<channel id="jmsQueueChannel">
		<queue />
	</channel>

	<!-- AMQP -->

	<int-amqp:inbound-channel-adapter id="testAmqp"
		queue-names="si.test.queue" connection-factory="rabbitConnectionFactory"
		channel="testAmqpInChannel" />

	<channel id="testAmqpInChannel" />
	<json-to-object-transformer input-channel="testAmqpInChannel"
		output-channel="amqpQueueChannel" />

	<channel id="amqpQueueChannel">
		<queue />
	</channel>

	<!-- Kafka -->
	<channel id="inputFromKafka" />
	<channel id="kafkaQueueChannel">
		<queue />
		<!-- <interceptors> <wire-tap channel="loggingChannel1" /> </interceptors> -->
	</channel>

	<logging-channel-adapter id="loggingChannel1"
		log-full-message="true" level="ERROR" />


	<int-kafka:zookeeper-connect id="zookeeperConnect"
		zk-connect="localhost:2181" zk-connection-timeout="6000"
		zk-session-timeout="6000" zk-sync-time="2000" />

	<int-kafka:inbound-channel-adapter
		id="kafkaInboundChannelAdapter" kafka-consumer-context-ref="consumerContext"
		group-id="default2" auto-startup="true" channel="kafkaQueueChannel">
		<poller fixed-delay="100" time-unit="MILLISECONDS" />
	</int-kafka:inbound-channel-adapter>

	<!-- <beans:bean id="kafkaReflectionDecoder" class="org.springframework.integration.kafka.serializer.avro.AvroReflectDatumBackedKafkaDecoder"> 
		<beans:constructor-arg type="java.lang.Class" value="java.lang.String"/> 
		</beans:bean> <beans:bean id="kafkaSpecificDecoder" class="org.springframework.integration.kafka.serializer.avro.AvroSpecificDatumBackedKafkaDecoder"> 
		<beans:constructor-arg value="com.mediahound.graph.domain.Book" /> </beans:bean> -->

	<beans:bean id="consumerProperties"
		class="org.springframework.beans.factory.config.PropertiesFactoryBean">
		<beans:property name="properties">
			<beans:props>
				<beans:prop key="auto.offset.reset">smallest</beans:prop>
				<beans:prop key="socket.receive.buffer.bytes">10485760</beans:prop> <!-- 10M -->
				<beans:prop key="fetch.message.max.bytes">5242880</beans:prop>
				<beans:prop key="auto.commit.interval.ms">1000</beans:prop>
			</beans:props>
		</beans:property>
	</beans:bean>

	<int-kafka:consumer-context id="consumerContext"
		consumer-timeout="1000" zookeeper-connect="zookeeperConnect"
		consumer-properties="consumerProperties">
		<int-kafka:consumer-configurations>
			<!-- <int-kafka:consumer-configuration group-id="default1" value-decoder="kafkaSpecificDecoder" 
				key-decoder="kafkaReflectionDecoder" max-messages="5000"> <int-kafka:topic 
				id="test1" streams="4"/> </int-kafka:consumer-configuration> -->
			<int-kafka:consumer-configuration
				group-id="default2" max-messages="50">
				<int-kafka:topic-filter pattern="test2"
					streams="4" />
			</int-kafka:consumer-configuration>
			<!-- <int-kafka:consumer-configuration group-id="default3" max-messages="10"> 
				<int-kafka:topic-filter pattern="regextopic.*" streams="4" exclude="false"/> 
				</int-kafka:consumer-configuration> -->
		</int-kafka:consumer-configurations>
	</int-kafka:consumer-context>
	<!-- <beans:bean id="partitionlessTransformer" class="org.springframework.integration.samples.kafka.outbound.PartitionlessTransformer"/> 
		<transformer ref="partitionlessTransformer" method="transform" input-channel="inputFromKafka" 
		output-channel="kafkaQueueChannel"/> -->
	<!-- <json-to-object-transformer input-channel="inputFromKafka" output-channel="kafkaQueueChannel" 
		/> -->

	<!-- ZeroMq -->
	<beans:bean id="jeroMqSub"
		class="org.neo4j.extensions.spring.common.ZeroMQSubscriber"
		init-method="init" destroy-method="cleanUp">
		<beans:property name="port" value="9998" />
	</beans:bean>

	<!-- <inbound-channel-adapter ref="jeroMqSub" method="recieveMessage" channel="zeroMqQueueChannel"> 
		<poller fixed-rate="1" /> </inbound-channel-adapter> -->

	<channel id="zeroMqQueueChannel">
		<queue />
		<interceptors>
			<wire-tap channel="loggingChannel1" />
		</interceptors>
	</channel>

	<!-- <bean id="jeroMqSubWrapper" class="ZeroMQInbound">
		<constructor-arg ref="jeroMqSub" />
	</bean> -->

	<beans:bean id="pollThread" class="java.lang.Thread" init-method="start"
		destroy-method="interrupt">
		<beans:constructor-arg ref="jeroMqSub" />
	</beans:bean>

</beans:beans>
